# Задача №3 - выбрать метод заполнения готовых документов с сохранением первоначального внешнего вида

## Процесс решения
Проблема с заполнением шаблонов документов информацией заключается в том, что менять структуру документа нельзя категорически. Головная организация, предоставляющая шаблоны формуляров, ставит условие по сохранению первоначальной структуры документа: изображения, отступы, водяные знаки, таблицы.
Возможные решения:

Для заполнения файлов текстом из пользовательской формы существует несколько вариантов:

1. внесение изменений в оригинальный docx файл при помощи библиотек
2. преобразование odt в zip архив для модификации xml, архивирование обратно в zip и смена формата на odt через смену формата
3. преобразование файлов Word в PDF и настройка заполняемых полей

Рассмотрим каждый из вариантов и выберем наиболее удобный по степени сложности реализации.
Стоит помнить об особенностях работы с файлами Word. При заполнении документов таким образом весь набранный текст имеет свойство сдвигаться по строкам, поэтому для корректного заполнения шаблонов от РКФ необходимо предварительно посчитать количество допустимых к вводу символов для каждого поля. 
Следующая особенность в работу с Word документами - технический вопрос. Для работы с файлами может понадобиться их заранее преобразовать в другие форматы для обеспечения возможности заполнения при помощи программного кода. Для корректной работы можно работать с ZIP и XML файлами. Это повышает сложность сохранения у документа его первоначального вида и повышает риск нарушения его структуры, что в случае системы недопустимо.

Важной особенностью в работе с Word форматом является использование соответствующих технологий. Заполнение файлом может быть реализовано при помощи COM-объектов, но это трудозатратно и требует наличие Microsoft Word на стороне клиента и сервера. Также данный способ ограничивает нас в возможности портирования сервиса на другие платформы кроме персональных компьютеров на операционной системе Windows. Решение данной проблемы может стать создание отдельного агента на операционной системе Windows, который будет взаимодействовать с файлами Word и по завершении преобразований отсылать готовый документ к системе. Последняя из выявленных проблем, лежащих на поверхности, это различия в работе с файлами Word различных версий программы. Отличие версии гарантирует разность в восприятии электронным устройством информации из файла и нарушение разметки внутри файла, что недопустимо для системы.

В первом случае главной трудностью может стать отсутсвтие необходимой библиотеки для Qt и C++. Данную проблему давно решили и она не является критичной для проекта. Популярным решением стала duckX, которая внутри себя имеет функционал по модификации docx файлов через модификацию xml файла без необходимости делать это вручную пользователем. Данная библиотека очень удобна в использовании и сокращает время в написании кода по парсингу файла контекста. Другим возможным способом взаимодействия с файлами может стать формат odt. 

Во втором случае можно прибегнуть в другому формату файлаов. Файлы odt формата имеют особенности по модификации при помощи программного кода. Если вносить изменения напрямую при помощи замены слова-маркера на то, что нам нужно, структура файла изменится таким образом, что повторное чтение файла окажется невозможным в видуу особенностей строения odt. По этой причине нужно первоначально распаковать файл и в файле context.xml найти слово-маркер при помощи парсинга, сохранить файл, заархивровать файл обратно в zip и сменить формат на odt. Много механических действий.

Во третьем случае решается несколько из выше упомянутых проблем и сложностей работы с документами в формате Word. Во-первых, PDF файлы не подвержены сдвигу текста при его вводе в заполняемые поля. Во-вторых, версионность не подвергает разметку информации внутри файлов изменениям. В-третьих, для обработки PDF файлов достаточно подключения специальных библиотек, нет необходимости преобразовывать файлы в ZIP и XML как в первом случае. Однако, данный метод имеет свои недоставки в том числе. По сколько такие файлы изначально не подразумевают заполнение, необходимо вставить поля для ввода текста. Далее рассчитать количество символов для корректного отображения после переноса текста из формы в поле. Как отмечалось ранее Word имеет ограничения в работе на других системах. PDF не имеет таких ограничений и имеет возможность отрисовки для всех известных платформах, что делает его более универсальным в использовании.

Для окончательного выбора способа реализации взаимодействия с документами необходимо разработать несколько тестовых проектов с функционалом по записи информации внутрь документов и проверки конечного внешнего вида.

#### ПРИМЕР КОДА С ИСПОЛЬЗОВАНИЕМ БИБЛИОТЕКИ DUCKX (первый способ)
```
1  void replace_marker_function()
2  { 
3      duckx::Document doc(<путь к файлу>);
4      doc.open();                          # открытие файла
5      if (doc.is_open())                   # проверка факта открытия файла
6      {
7          for (duckx::Paragraph p = doc.paragraphs(); p.has_next(); p.next())
8          { # пробежка по параграфам
9               for (duckx::Run r = p.runs(); r.has_next(); r.next())
10              {
11                  string t = r.get_text();                  # взятие строки
12                  QString str = QString::fromStdString(t);  # преобразовывание в QString
13  
14                  if (str.contains("NameOfTheClubPutHere")) # поиск слова-маркера
15                  {
16                      str.replace("NameOfTheClubPutHere", QString::number(123)); # замена
17                      r.set_text(str.toStdString());                             # смена формата строки
18                      doc.save();                                                # сохранение
19                  }
20              }
21          }
22      }
23 }
```
В данном примере кода показывается способ замены слова-маркера на число 123. 
Функция предварительно проверяет возможность открытия файла по указанному пути (3-5 строки).
Рассматриваемая библиотека имеет внутри себя функционал по модификации xml файла. При использовании библиотеки нет необходимости самостоятельно парсить файл на поиск нужной информации, duckX делает это самостоятельно. (7-9 строки). Поочерёдно считывается каждая строка (11 строка), преобразовывается в QString (12 строка), внутри которой и пытается найти слово-маркер, поставленное в файл заранее (14-19 строки).
После успешной замены файл каждый раз сохраняется. Таким образом можно заменять необхожимое количество слов внутри файла формата docx без смен формата и ручного парсинга.

#### ПРИМЕР КОДА С ИЗМЕНЕНИЯМИ СОДЕРЖИМОГО ФАЙЛА *CONTEXT.XML* (второй способ)
```
1   bool Widget::editContentXml(const QString& xmlFilePath)
2   {
3      QString nameOfTheClub = ui->lineEdit_1->text(); # получение слова для замена маркера
4   
5      if (!QFile::exists(xmlFilePath)) return false;  # проверка существования файла
6   
7      QFile file(xmlFilePath);
8      if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) return false;
9   
10     QDomDocument doc;
11     QString errorMsg;
12     int errorLine, errorColumn;
13  
14     if (!doc.setContent(&file, &errorMsg, &errorLine, &errorColumn)) file.close();
15     file.close();
16  
17     QDomNodeList spans = doc.elementsByTagName("text:span");
18     int replacementsCount = 0;
19  
20     for (int i = 0; i < spans.count(); i++)
21       {
22         QDomNode node = spans.at(i);
23         QDomElement span = node.toElement();
24         if (span.isNull()) continue;
25  
26         QString spanText = span.text();
27  
28         if (spanText == "nameOfTheClud") 
29         {
30             QDomNodeList children = span.childNodes();
31             for (int j = children.size() - 1; j >= 0; --j)
32               {
33                 span.removeChild(children.at(j));
34             }
35             span.appendChild(doc.createTextNode(nameOfTheClub));
36             replacementsCount++;
37        }
38     }
39         if (!file.open(QIODevice::WriteOnly || QIODevice::Text)) return false;
40  
41         QTextStream stream(&file);
42         doc.save(stream, 4);
43         file.close();
44         return true;
45  }
```
В следующем примере был реализован ручной парсинг информации из context.xml, предварительно полученного в результате разархивации файла odt формата.и Функция как в прошлый раз начинает работу с проверки возмодноости открытия файла, возвращая *false*, если попытка оказаласт провальной (5 строка). 
При просмотре структуры *context.xml* оказалось, что нужный текст находится внутри тегов *span*. По этой причине функция анализирует имено их. Каждый пустой *span* пропускается (24 строка), инструкция по замене слова-маркера срабатывает при аналогичном условии, как и в первом варианте реализации кода (28 строка). После выполнения всех замен файл сохраняется и закрывается для ввода новой информации (43 строка).

Сравним 2 функции по замене текста при двух разных сценариях. В результате сравнительного анализа можно сделать следующие выводы:

1. Редактирование docx при помощи использования библиотеки duckX значительно менее объёмно, что упрощает понимание программного кода. 
2. Использование библиотки значительно проще, по сравнением с модификацией XML файлов. Для корректной модификации XML файла необходимо найти слова-маркеры внутри тегов файла. Без знания структуры файла сделать это значительно трудозатратнее, чем модифицировать сразу docx файл.
3. DuckX не принуждает взаимодействовать с распакованным odt файлом. Для восстановления возможности чтения необходимо архивировать файлы обратно в zip формат и менять на odt, что не гарантирует получение читаемого файла обратно

## Непредвиденные обстоятельства
При написании программного кода по замене 20+ маркеров внутри docx файла выяснилось, что у написанной библиотеки есть одна неприятная особенность работы с файлами. Используемая библиотека не на 100% корректно работает с XML файлами внутри docx. При перезаписи файла случаются удаления пробелов внутри параграфов, так как код библиотеки счиает пробелы лишними и неныжными, что заставляет их убирать при перезаписи. 

## Костыльное решение проблемы
В качестве решения было принята мера по написанию кода по замене текста внутри docx файла на **Python** версии **3.12** с помощью библиотеки python-docx, которая без утраты первоначального форматирования способна на замены текста. Принцип работы изменился на следующий: C++ всё также отрисовывает пользовательсую форму и элементы QLineEdit для ввода информации, однако теперь вместо прямой замены сразу по нажатию кнопки сначала происходит формирование **json** файла с маркерами и значениями для замены, который читается кодом, написанным в отдельном **py** файле, где происходит замены в параграфах и таблицах.

Смотря на принцип работы с документами в программе было принято решение по созданию отдельного скрипта по замене маркеров на значения, вводимые пользователями. 

#### ПРОГРАММНЫЙ КОД СТРАНИЦЫ ЗАПОЛНЕНИЯ ШАБЛОНА
```
1  void::Widget::on_clicked_switchPage()
2  {
3      QString pythonScript   = "C:";
4      QString fileCopyScript = "C:";
5      QString docxPath       = "C:";
6
7      QProcess::startDetached("C:/python.exe", {fileCopyScript, docxPath});
8  
9      QString jsonPath     = "C:/qt_projects/Python_hybrid_test/file_editing/data.json";
10 
11     QJsonObject breed_strings;
12     breed_strings.insert("NamePutOfTheClubHere"    ,ui->lineEdit_1->text());
13     ...
14     breed_strings.insert("PutYourCurrentAdress",ui->lineEdit_10->text());
15 
16     QJsonDocument doc(breed_strings);
17     QFile file(jsonPath);
18 
19     if (file.open(QIODevice::WriteOnly))
20     {
21         file.write(doc.toJson());
22         file.close();
23     }
24     else
25     {
26         qDebug() << "Could not create JSON file at:" << jsonPath;
27        return;
28     }
29
30     QProcess::startDetached("C:python.exe", {pythonScript, docxPath, jsonPath});
31
32     MainWindow *second_page = new MainWindow();
33     this->hide();
34     second_page->show();
35 }
```

Приведённый выше код имеет в себе несколько функций, неоьходимых для корректного заполнения документа формата docx. Вставленный пример - функция **on_clicked_switchPage**, которая выполняет определённый набор действий:
1. создаёт точную копию оригинального шаблона для упрощения отследивания работы по замене и автоматизация поставки шаблона для заполнения 
##### Скрипт по копированию файла шаблона для заполнения
```
1  from docx import Document
2
3  def copy_file(orig_file_path, copy_file_path):
4      doc = Document(orig_file_path)
5      doc.save(copy_file_path)
6      print("================ \n" + "copying finished \n" + "================ \n")
7
8  if __name__ == "__main__":
9      u_orig_file_path = 'C:/qt_projects/Python_hybrid_test/file_editing/test_2.docx'
10     u_copy_file_path = 'C:/qt_projects/Python_hybrid_test/file_editing/copy_test3.docx'
11     copy_file(u_orig_file_path, u_copy_file_path)
```
Работа кода обеспечена библиотекой python-docx. Читается файл шаблона (строка 4), после чего сохраняется копия (строка 5). Для копирования захардкодены файловые пути. Копия обновляется каждый раз при запуске функции **on_clicked_switchPage**. Для отслеживания работы печатаются отчётные строки (строка 6).

2. Инициализация JSON файла для дальнейшей передачи информацции скрипту по замене текста (строки 9 - 17)
3. Проверка возможности прочтения файла для корректной работы скрипта (строки 19 - 28)
4. Вызов скрипта для замены текста (строка 30)
5. Создание следующей страницы для заполнения документа (строки 32 - 34)

##### Скрипт по замене текста в шаблоне из JSON файла по логике маркер - значение в тексте и таблицах
```
1  import json
2  from docx import Document
3
4
5  def mass_replace(json_path, copy_file_path):
6      print("\n replacement started")
7      with open(json_path, 'r', encoding='utf-8') as f:
8          replacements = json.load(f)
9
10     doc = Document(copy_file_path)
11
12     def replace_in_paragraphs(paragraphs):
13         for p in paragraphs:
14             for run in p.runs:
15                 for key, value in replacements.items():
16                     if key in run.text:
17                         run.text = run.text.replace(key, str(value))
18
19     replace_in_paragraphs(doc.paragraphs)
20 
21     for table in doc.tables:
22         for row in table.rows:
23             for cell in row.cells:
24                 replace_in_paragraphs(cell.paragraphs)
25
26     doc.save(copy_file_path)
27     print("replacement finished")
```
Представленная фнукция по замене маркеров внутри файла копии представляет собой пробег по всему текстовому содержимому файла и нахождения маркеров из JSON файла, где напротив каждого установлено значение, на которое нужно заменить маркер. Пока нет проверов на ввод слишком длинных конструкций или правильности типа вводимых данных. Планируется к добавлениюю позже. Главная цель - добиться замены всех маркеров в файле копии шаблона. 


## Конечный вывод (*под сомнением*)
В виду очевидных преимуществ duckX было решено не пробовать способы по модификации PDF файлов. Более благоразумным решением будет выбрать способ по использованию библиотеки duckX для работы с файлами формата docx без смены формата, задействования архиваторов и других сторонних программ, отдавая приоритет библиотеке, которая имеет весь необходимый функционал внутри себя.

## Конечный вывод №2
В ходе практических испытаний было выявлена некорректная работы библиотеки duckx в файлами, имеющими сложное форматирование. Для достижения поставленной задачи было принято решение по написанию отдельных скриптов по замене текста на Python с использованием библиотеки python-docx. 