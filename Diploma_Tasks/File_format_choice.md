# Задача №3 - выбрать метод заполнения готовых документов с сохранением первоначального внешнего вида

## Процесс решения
Проблема с заполнением шаблонов документов информацией заключается в том, что менять структуру документа нельзя категорически. Головная организация, предоставляющая шаблоны формуляров, ставит условие по сохранению первоначальной структуры документа: изображения, отступы, водяные знаки, таблицы.
Возможные решения:

Для заполнения файлов текстом из пользовательской формы существует несколько вариантов:

1. внесение изменений в оригинальный docx файл при помощи библиотек
2. преобразование odt в zip архив для модификации xml, архивирование обратно в zip и смена формата на odt через смену формата
3. преобразование файлов Word в PDF и настройка заполняемых полей

Рассмотрим каждый из вариантов и выберем наиболее удобный по степени сложности реализации.
Стоит помнить об особенностях работы с файлами Word. При заполнении документов таким образом весь набранный текст имеет свойство сдвигаться по строкам, поэтому для корректного заполнения шаблонов от РКФ необходимо предварительно посчитать количество допустимых к вводу символов для каждого поля. 
Следующая особенность в работу с Word документами - технический вопрос. Для работы с файлами может понадобиться их заранее преобразовать в другие форматы для обеспечения возможности заполнения при помощи программного кода. Для корректной работы можно работать с ZIP и XML файлами. Это повышает сложность сохранения у документа его первоначального вида и повышает риск нарушения его структуры, что в случае системы недопустимо.

Важной особенностью в работе с Word форматом является использование соответствующих технологий. Заполнение файлом может быть реализовано при помощи COM-объектов, но это трудозатратно и требует наличие Microsoft Word на стороне клиента и сервера. Также данный способ ограничивает нас в возможности портирования сервиса на другие платформы кроме персональных компьютеров на операционной системе Windows. Решение данной проблемы может стать создание отдельного агента на операционной системе Windows, который будет взаимодействовать с файлами Word и по завершении преобразований отсылать готовый документ к системе. Последняя из выявленных проблем, лежащих на поверхности, это различия в работе с файлами Word различных версий программы. Отличие версии гарантирует разность в восприятии электронным устройством информации из файла и нарушение разметки внутри файла, что недопустимо для системы.

В первом случае главной трудностью может стать отсутсвтие необходимой библиотеки для Qt и C++. Данную проблему давно решили и она не является критичной для проекта. Популярным решением стала duckX, которая внутри себя имеет функционал по модификации docx файлов через модификацию xml файла без необходимости делать это вручную пользователем. Данная библиотека очень удобна в использовании и сокращает время в написании кода по парсингу файла контекста. Другим возможным способом взаимодействия с файлами может стать формат odt. 

Во втором случае можно прибегнуть в другому формату файлаов. Файлы odt формата имеют особенности по модификации при помощи программного кода. Если вносить изменения напрямую при помощи замены слова-маркера на то, что нам нужно, структура файла изменится таким образом, что повторное чтение файла окажется невозможным в видуу особенностей строения odt. По этой причине нужно первоначально распаковать файл и в файле context.xml найти слово-маркер при помощи парсинга, сохранить файл, заархивровать файл обратно в zip и сменить формат на odt. Много механических действий.

Во третьем случае решается несколько из выше упомянутых проблем и сложностей работы с документами в формате Word. Во-первых, PDF файлы не подвержены сдвигу текста при его вводе в заполняемые поля. Во-вторых, версионность не подвергает разметку информации внутри файлов изменениям. В-третьих, для обработки PDF файлов достаточно подключения специальных библиотек, нет необходимости преобразовывать файлы в ZIP и XML как в первом случае. Однако, данный метод имеет свои недоставки в том числе. По сколько такие файлы изначально не подразумевают заполнение, необходимо вставить поля для ввода текста. Далее рассчитать количество символов для корректного отображения после переноса текста из формы в поле. Как отмечалось ранее Word имеет ограничения в работе на других системах. PDF не имеет таких ограничений и имеет возможность отрисовки для всех известных платформах, что делает его более универсальным в использовании.

Для окончательного выбора способа реализации взаимодействия с документами необходимо разработать несколько тестовых проектов с функционалом по записи информации внутрь документов и проверки конечного внешнего вида.

#### ПРИМЕР КОДА С ИСПОЛЬЗОВАНИЕМ БИБЛИОТЕКИ DUCKX (первый способ)
```
1  void replace_marker_function()
2  { 
3      duckx::Document doc(<путь к файлу>);
4      doc.open();                          # открытие файла
5      if (doc.is_open())                   # проверка факта открытия файла
6      {
7          for (duckx::Paragraph p = doc.paragraphs(); p.has_next(); p.next())
8          { # пробежка по параграфам
9               for (duckx::Run r = p.runs(); r.has_next(); r.next())
10              {
11                  string t = r.get_text();                  # взятие строки
12                  QString str = QString::fromStdString(t);  # преобразовывание в QString
13  
14                  if (str.contains("NameOfTheClubPutHere")) # поиск слова-маркера
15                  {
16                      str.replace("NameOfTheClubPutHere", QString::number(123)); # замена
17                      r.set_text(str.toStdString());                             # смена формата строки
18                      doc.save();                                                # сохранение
19                  }
20              }
21          }
22      }
23 }
```
В данном примере кода показывается способ замены слова-маркера на число 123. 
Функция предварительно проверяет возможность открытия файла по указанному пути (3-5 строки).
Рассматриваемая библиотека имеет внутри себя функционал по модификации xml файла. При использовании библиотеки нет необходимости самостоятельно парсить файл на поиск нужной информации, duckX делает это самостоятельно. (7-9 строки). Поочерёдно считывается каждая строка (11 строка), преобразовывается в QString (12 строка), внутри которой и пытается найти слово-маркер, поставленное в файл заранее (14-19 строки).
После успешной замены файл каждый раз сохраняется. Таким образом можно заменять необхожимое количество слов внутри файла формата docx без смен формата и ручного парсинга.

#### ПРИМЕР КОДА С ИЗМЕНЕНИЯМИ СОДЕРЖИМОГО ФАЙЛА *CONTEXT.XML* (второй способ)
```
1   bool Widget::editContentXml(const QString& xmlFilePath)
2   {
3      QString nameOfTheClub = ui->lineEdit_1->text(); # получение слова для замена маркера
4   
5      if (!QFile::exists(xmlFilePath)) return false;  # проверка существования файла
6   
7      QFile file(xmlFilePath);
8      if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) return false;
9   
10     QDomDocument doc;
11     QString errorMsg;
12     int errorLine, errorColumn;
13  
14     if (!doc.setContent(&file, &errorMsg, &errorLine, &errorColumn)) file.close();
15     file.close();
16  
17     QDomNodeList spans = doc.elementsByTagName("text:span");
18     int replacementsCount = 0;
19  
20     for (int i = 0; i < spans.count(); i++)
21       {
22         QDomNode node = spans.at(i);
23         QDomElement span = node.toElement();
24         if (span.isNull()) continue;
25  
26         QString spanText = span.text();
27  
28         if (spanText == "nameOfTheClud") 
29         {
30             QDomNodeList children = span.childNodes();
31             for (int j = children.size() - 1; j >= 0; --j)
32               {
33                 span.removeChild(children.at(j));
34             }
35             span.appendChild(doc.createTextNode(nameOfTheClub));
36             replacementsCount++;
37        }
38     }
39         if (!file.open(QIODevice::WriteOnly || QIODevice::Text)) return false;
40  
41         QTextStream stream(&file);
42         doc.save(stream, 4);
43         file.close();
44         return true;
45  }
```
В следующем примере был реализован ручной парсинг информации из context.xml, предварительно полученного в результате разархивации файла odt формата.и Функция как в прошлый раз начинает работу с проверки возмодноости открытия файла, возвращая *false*, если попытка оказаласт провальной (5 строка). 
При просмотре структуры *context.xml* оказалось, что нужный текст находится внутри тегов *span*. По этой причине функция анализирует имено их. Каждый пустой *span* пропускается (24 строка), инструкция по замене слова-маркера срабатывает при аналогичном условии, как и в первом варианте реализации кода (28 строка). После выполнения всех замен файл сохраняется и закрывается для ввода новой информации (43 строка).

Сравним 2 функции по замене текста при двух разных сценариях. В результате сравнительного анализа можно сделать следующие выводы:

1. Редактирование docx при помощи использования библиотеки duckX значительно менее объёмно, что упрощает понимание программного кода. 
2. Использование библиотки значительно проще, по сравнением с модификацией XML файлов. Для корректной модификации XML файла необходимо найти слова-маркеры внутри тегов файла. Без знания структуры файла сделать это значительно трудозатратнее, чем модифицировать сразу docx файл.
3. DuckX не принуждает взаимодействовать с распакованным odt файлом. Для восстановления возможности чтения необходимо архивировать файлы обратно в zip формат и менять на odt, что не гарантирует получение читаемого файла обратно

## Конечный вывод
В виду очевидных преимуществ duckX было решено не пробовать способы по модификации PDF файлов. Более благоразумным решением будет выбрать способ по использованию библиотеки duckX для работы с файлами формата docx без смены формата, задействования архиваторов и других сторонних программ, отдавая приоритет библиотеке, которая имеет весь необходимый функционал внутри себя.