# Задача №1 - выбор метода заполнения готовых шаблонов документов без потери первоначального вида с сохранением наложенных изображений

## Процесс решения

Головная организация - автор документов в формате Word для занесения информации по различным категориям и мероприятиям. Шаблоны, которые на данный момент заполняются от руки, утверждены РКФ и не могут быть изменены. 
Проблема - заполнение шаблонов документов информацией таким образом, чтобы не менять структуру документа и сохранить все полупрозрачные изображения на их первоначальных местах.
Возможные решения:

- создание предварительных пользовательских форм для заполнения и перенос из них информации в шаблонный документ Word
- преобразование файлов Word в PDF и настройка заполняемых полей
- преобразование odt в zip архив для модификации xml, архивирование обратно в zip и смена формата на odt через смену имени
- использование специализированных библиотек для работы с форматами файлов

Рассмотрим каждый из вариантов и выберем наиболее удобный по степени сложности реализации.
В первом случае стоит помнить об особенностях работы с файлами Word. При заполнении документов таким образом весь набранный текст имеет свойство сдвигаться по строкам, поэтому для корректного заполнения шаблонов от РКФ необходимо предварительно посчитать количество допустимых к вводу символов для каждого поля. 
Следующая особенность в работу с Word документами - технический вопрос. Для работы с файлами необходимо их заранее преобразовать в другие форматы для обеспечения возможности заполнения при помощи программного кода. Для корректной работы необходимо работать с ZIP и XML файлами. Это повышает сложность сохранения у документа его первоначального вида и повышает риск нарушения его структуры, что в случае системы недопустимо.

Важной особенностью в работе с Word форматом является использование соответствующих технологий. Заполнение файлом может быть реализовано при помощи COM-объектов, но это трудозатратно и требует наличие Microsoft Word на стороне клиента и сервера. Также данный способ ограничивает нас в возможности портирования сервиса на другие платформы кроме персональных компьютеров на операционной системе Windows. Решение данной проблемы может стать создание отдельного агента на операционной системе Windows, который будет взаимодействовать с файлами Word и по завершении преобразований отсылать готовый документ к системе. Последняя из выявленных проблем, лежащих на поверхности, это различия в работе с файлами Word различных версий программы. Отличие версии гарантирует разность в восприятии электронным устройством информации из файла и нарушение разметки внутри файла, что недопустимо для системы.
Другим возможным способом взаимодействия с файлами может стать формат odt. 

Во втором случае решается несколько из выше упомянутых проблем и сложностей работы с документами в формате Word. Во-первых, PDF файлы не подвержены сдвигу текста при его вводе в заполняемые поля. Во-вторых, версионность не подвергает разметку информации внутри файлов изменениям. В-третьих, для обработки PDF файлов достаточно подключения специальных библиотек, нет необходимости преобразовывать файлы в ZIP и XML как в первом случае. Однако, данный метод имеет свои недоставки в том числе. По сколько такие файлы изначально не подразумевают заполнение, необходимо вставить поля для ввода текста. Далее рассчитать количество символов для корректного отображения после переноса текста из формы в поле. Как отмечалось ранее Word имеет ограничения в работе на других системах. PDF не имеет таких ограничений и имеет возможность отрисовки для всех известных платформах, что делает его более универсальным в использовании.

Для окончательного выбора способа реализации взаимодействия с документами необходимо разработать несколько тестовых проектов с функционалом по записи информации внутрь документов и проверки конечного внешнего вида.

#### ПРИМЕР КОДА С ИСПОЛЬЗОВАНИЕМ БИБЛИОТЕКИ DUCKX
```
void test_function(){
    duckx::Document doc(<путь к файлу>);
    doc.open();
    if (doc.is_open()) {
        for (duckx::Paragraph p = doc.paragraphs(); p.has_next(); p.next()){
            for (duckx::Run r = p.runs(); r.has_next(); r.next()){
                string t = r.get_text();
                QString str = QString::fromStdString(t);

                if (str.contains("NameOfTheClubPutHere")){
                    str.replace("NameOfTheClubPutHere", QString::number(123));
                    r.set_text(str.toStdString());
                    doc.save();
                }
            }
        }
    }
}
```

#### ПРИМЕР КОДА С ИЗМЕНЕНИЯМИ В XML ФАЙЛА
```
bool Widget::editContentXml(const QString& xmlFilePath){
    QString nameOfTheClub = ui->lineEdit_1->text();

    if (!QFile::exists(xmlFilePath)) return false;

    QFile file(xmlFilePath);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) return false;

    QDomDocument doc;
    QString errorMsg;
    int errorLine, errorColumn;

    if (!doc.setContent(&file, &errorMsg, &errorLine, &errorColumn)) file.close();
    file.close();

    QDomNodeList spans = doc.elementsByTagName("text:span");
    int replacementsCount = 0;

    for (int i = 0; i < spans.count(); i++) {
        QDomNode node = spans.at(i);
        QDomElement span = node.toElement();
        if (span.isNull()) continue;

        QString spanText = span.text();

        if (spanText == "nameOfTheClud") {
            QDomNodeList children = span.childNodes();
            for (int j = children.size() - 1; j >= 0; --j) {
                span.removeChild(children.at(j));
            }
            span.appendChild(doc.createTextNode(nameOfTheClub));
            replacementsCount++;
        }

    if (!file.open(QIODevice::WriteOnly || QIODevice::Text)) return false;

    QTextStream stream(&file);
    doc.save(stream, 4);
    file.close();
    return true;
}
```

Сравним 2 функции по замене текста при двух разных сценариях. В результате сравнительного анализа можно сделать следующие выводы:

1. Редактирование docx при помощи использования библиотеки duckX значительно менее объёмно, что упрощает понимание программного кода. 
2. Использование библиотки значительно проще, по сравнением с модификацией XML файлов. Для корректной модификации XML файла необходимо найти слова-маркеры внутри тегов файла. Без знания структуры файла сделать это значительно трудозатратнее, чем модифицировать сразу docx файл.
3. DuckX не принуждает взаимодействовать с распакованным odt файлом. Для восстановления возможности чтения необходимо архивировать файлы обратно в zip формат и менять на odt, что не гарантирует получение читаемого файла обратно

## Конечный вывод
В конечном итоге, более благоразумным решением будет выбрать способ по использованию библиотеки duckX для работы с файлами формата docx без смены формата, задействования архиваторов и других сторонних программ.